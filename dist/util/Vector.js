/* minified */
define(require=>{"use strict";const t=require("SIM_CORE/util/assert");class e{constructor(e,i,s=!1){t("number"==typeof e,`invalid x: ${e}`),t("number"==typeof i,`invalid y: ${i}`),t("boolean"==typeof s,`invalid isImmutable: ${s}`),this._x=e,this._y=i,this._isImmutable=s}get x(){return this._x}get y(){return this._y}getMagnitude(){return Math.sqrt(this._x*this._x+this._y*this._y)}get magnitude(){return this.getMagnitude()}distanceToXY(e,i){return t("number"==typeof e,`invalid x: ${e}`),t("number"==typeof i,`invalid y: ${i}`),Math.sqrt(Math.pow(this._x-e,2)+Math.pow(this._y-i,2))}distanceTo(i){return t(i instanceof e,`invalid point: ${i}`),this.distanceToXY(i.x,i.y)}equals(i){return t(i instanceof e,`invalid vector: ${i}`),this._x===i.x&&this._y===i.y}equalsEpsilon(i,s=5e-5){return t(i instanceof e&&"number"==typeof s),Math.max(Math.abs(this._x-i.x),Math.abs(this._y-i.y))<=s}isFinite(){return isFinite(this._x)&&isFinite(this._y)}copy(t=!1){return new e(this._x,this._y,t)}getAngle(){return Math.atan2(this._y,this._x)}get angle(){return this.getAngle()}toString(){return`<${this._x}, ${this._y}>`}setX(e){return t(!1===this._isImmutable,"cannot mutate a mutable"),t("number"==typeof e,`invalid x: ${e}`),this._x=e,this}set x(t){this.setX(t)}setY(e){return t(!1===this._isImmutable,"cannot mutate a mutable"),t("number"==typeof e,`invalid y: ${e}`),this._y=e,this}set y(t){this.setY(t)}set(i){return t(!1===this._isImmutable,"cannot mutate a mutable"),t(i instanceof e,`invalid vector: ${i}`),this.setX(i.x).setY(i.y)}multiply(e){return t(!1===this._isImmutable,"cannot mutate a mutable"),t("number"==typeof e,`invalid scalar: ${e}`),this.setX(this._x*e).setY(this._y*e)}divide(e){return t(!1===this._isImmutable,"cannot mutate a mutable"),this.multiply(1/e)}addXY(e,i){return t(!1===this._isImmutable,"cannot mutate a mutable"),t("number"==typeof e,`invalid x: ${e}`),t("number"==typeof i,`invalid y: ${i}`),this.setX(this._x+e).setY(this._y+i)}add(i){return t(!1===this._isImmutable,"cannot mutate a mutable"),t(i instanceof e,`invalid vector: ${i}`),this.addXY(i.x,i.y)}subtractXY(e,i){return t(!1===this._isImmutable,"cannot mutate a mutable"),t("number"==typeof e,`invalid x: ${e}`),t("number"==typeof i,`invalid y: ${i}`),this.setX(this._x-e).setY(this._y-i)}subtract(i){return t(!1===this._isImmutable,"cannot mutate a mutable"),t(i instanceof e,`invalid vector: ${i}`),this.subtractXY(i.x,i.y)}normalize(){t(!1===this._isImmutable,"cannot mutate a mutable");const e=this.magnitude;if(0!==e)return this.divide(e);t(!1,"Cannot normalize a zero-magnitude vector")}setAngle(e){t(!1===this._isImmutable,"cannot mutate a mutable"),t("number"==typeof e,`invalid angle: ${e}`);const i=this.getMagnitude();return this.x=i*Math.cos(e),this.y=i*Math.sin(e),this}set angle(t){this.setAngle(t)}rotate(e){return t(!1===this._isImmutable,"cannot mutate a mutable"),this.setAngle(e+this.angle)}rotateAboutXY(e,i,s){t(!1===this._isImmutable,"cannot mutate a mutable");const a=this.x-e,n=this.y-i,u=Math.cos(s),r=Math.sin(s);return this.x=e+a*u-n*r,this.y=i+a*r+n*u,this}rotateAboutPoint(t,e){return this.rotateAboutXY(t.x,t.y,e)}}return e.ZERO=new e(0,0,!0),e});